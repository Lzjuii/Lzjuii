
2.

#include<iostream>
#include<cstring>
using namespace std;
//定义需要支付最大金额
const int N = 1e5 + 10;
//a：用来接受纸币的数量，a[0]对应1元纸币的数量，a[1]对应2元纸币的数量，a[2]对应5元纸币的数量,....a[6]对应100元纸币的数量
int a[10];
//cp:用来转换a数组的下标为对应的纸币金额，cp[0]对应1元，cp[1]对应2元，cp[2]对应5元,...cp[6]对应100元
int cp[10];
//用来进行状态转移的数组，也是获取最终答案的数组
//dp[i]代表支付i元需要的最少纸币
//状态转移方程为：dp[i] = min(dp[i], dp[i - x] + 1); x为当前纸币的金额
int dp[N];
//初始化cp数组
void init()
{
    cp[0] = 1, cp[1] = 2, cp[2] = 5, cp[3] = 10, cp[4] = 20, cp[5] = 50, cp[6] = 100;
}

int main()
{
    //输入每一种纸币的数量
    for(int i = 0; i < 7; i++)
    {
        cin >> a[i];
    }
    //初始化cp数组
    init();
    //初始化设置支付i元需要的纸币数量为正无穷多，为状态转移做准备
    memset(dp, 0x3f, sizeof dp);
    //支付0元需要的纸币数量为0
    dp[0] = 0;
    //输入需要支付的k元
    int k;
    cin >> k;
    //进行状态转移，遍历每一种纸币
    for(int i = 0; i < 7; i++)
    {
        //创建变量x对应cp[i],即当前这个纸币的价格
        int x = cp[i];
        //num对应a[i],即当前这种纸币有的数量
        int num = a[i];
        //一共使用num次，对每一次进行选或不选的操作
        while(num--)
        {
            //进行状态转移遍历
            for(int j = k; j >= x; j--)
            {
                //进行状态转移
                dp[j] = min(dp[j], dp[j - x] + 1);
            }
        }
    }
    //dp[k]即是支付k元需要的最少的纸币需要，如果满足不了，则输出的值为：1061109567 ->转换成16进制表达为：0x3f3f3f3f
    cout << dp[k] << endl;
    return 0;
}
