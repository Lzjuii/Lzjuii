#include <iostream>  
using namespace std;  
typedef struct   
{  
    int r[100+1];  
    int length;  
}SqList;  
//二路归并函数  
void Merge(SqList &L,int low,int m,int high)  
{//将两个有序区归并为一个有序区  
    int i,j,k;  
    i=low;//low为第一个有序区的第一个元素，i指向第一个元素  
    j=m+1;//m为第一个有序区的最后一个元素，m+1为第二个有序区第一个元素，j指向第一个元素  
    k=0;  
    int *t=new int[high-low+1];//t数组用来暂存合并的有序序列  
    if(!t)  
    {  
        cout<<"ERROR!";  
        return;  
    }  
    while(i<=m&&j<=high)//顺序选取两个有序区的较小元素，存储到t数组中  
        if(L.r[i]<=L.r[j])  
            t[k++]=L.r[i++];  
        else  
            t[k++]=L.r[j++];  
    while(i<=m)//若比较完之后，第一个有序区仍有剩余，则直接复制到t数组中  
        t[k++]=L.r[i++];  
    while(j<=high)//同上  
        t[k++]=L.r[j++];  
    for(i=low,k=0;i<=high;i++,k++)  
        L.r[i]=t[k];  
    delete []t;  
}  
//用递归应用二路归并函数实现排序——分治法  
void MergeSort(SqList &L,int low,int high)  
{  
    int mid;  
    if(low<high)  
    {  
        mid=(low+high)/2;  
        MergeSort(L,low,mid);  
        MergeSort(L,mid+1,high);  
        Merge(L,low,mid,high);  
    }  
}  
void MSort(SqList &L)  
{  
    MergeSort(L,1,L.length);  
}  
void main()  
{  
    //freopen("in.txt","r",stdin);  
    int i;  
    SqList L;  
    cin>>L.length;  
    for(i=1;i<=L.length;i++)  
        cin>>L.r[i];  
    MSort(L);  
    for(i=1;i<=L.length;i++)  
        cout<<L.r[i]<<" ";  
}  
